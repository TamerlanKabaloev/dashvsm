<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ò–º–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–ø—É—Å–∫–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 20px;
            background: #2c3e50;
            color: white;
        }

        .sidebar-header h1 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .control-group {
            padding: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        .control-group input,
        .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .element-palette {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 15px;
        }

        .element-button {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .element-button:hover {
            border-color: #3498db;
            background: #e8f4f8;
        }

        .element-button.active {
            border-color: #3498db;
            background: #3498db;
            color: white;
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            padding: 15px 20px;
            background: white;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }
        
        .btn.active {
            background: #2980b9;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #fafafa;
            overflow: auto;
            width: 100%;
            height: 100%;
        }

        #canvas {
            display: block;
            cursor: crosshair;
            background: #ffffff;
            min-width: 2000px;
            min-height: 1500px;
        }
        
        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        .results-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 400px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        .results-panel.visible {
            display: block;
        }

        .results-panel h2 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .result-item {
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }

        .result-item.bottleneck {
            border-left-color: #e74c3c;
            background: #ffeaea;
        }

        .result-item h3 {
            font-size: 14px;
            margin-bottom: 5px;
        }

        .result-item p {
            font-size: 12px;
            color: #666;
            margin: 3px 0;
        }

        .element-properties {
            padding: 15px;
            border-top: 1px solid #eee;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }

        .element-properties.visible {
            display: block;
        }
        
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #3498db;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
            display: none;
            z-index: 1000;
        }
        
        .resize-handle.visible {
            display: block;
        }
        
        .resize-handle.se {
            cursor: nwse-resize;
        }
        
        .resize-handle.sw {
            cursor: nesw-resize;
        }
        
        .resize-handle.ne {
            cursor: nesw-resize;
        }
        
        .resize-handle.nw {
            cursor: nwse-resize;
        }
        
        .density-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            padding: 5px 10px;
            background: rgba(255,255,255,0.9);
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            pointer-events: none;
        }
        
        .density-indicator.low {
            color: #27ae60;
        }
        
        .density-indicator.medium {
            color: #f39c12;
        }
        
        .density-indicator.high {
            color: #e74c3c;
        }

        .element-list {
            padding: 15px;
        }

        .element-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .element-item:hover {
            background: #e9ecef;
        }

        .element-item.selected {
            background: #d4edda;
            border: 2px solid #28a745;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .simulation-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-left: auto;
        }

        .simulation-info {
            padding: 5px 15px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>–ò–º–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏–µ</h1>
            <p style="font-size: 12px; opacity: 0.9;">–°–æ–∑–¥–∞–π—Ç–µ —Å—Ö–µ–º—É –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–∏–º—É–ª—è—Ü–∏—é</p>
        </div>

        <div class="control-group">
            <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—é–¥–µ–π:</label>
            <input type="number" id="peopleCount" value="10000" min="1" step="100">
        </div>

        <div class="control-group">
            <label>–í—Ä–µ–º—è —Å–∏–º—É–ª—è—Ü–∏–∏ (—Å–µ–∫):</label>
            <input type="number" id="simulationTime" value="3600" min="1" step="60">
        </div>

        <div class="control-group">
            <h3 style="margin-bottom: 10px;">–≠–ª–µ–º–µ–Ω—Ç—ã:</h3>
            <div class="element-palette">
                <div class="element-button" data-type="tunnel">–¢–æ–Ω–Ω–µ–ª—å</div>
                <div class="element-button" data-type="stairs">–õ–µ—Å—Ç–Ω–∏—Ü–∞</div>
                <div class="element-button" data-type="escalator">–≠—Å–∫–∞–ª–∞—Ç–æ—Ä</div>
                <div class="element-button" data-type="turnstile">–¢—É—Ä–Ω–∏–∫–µ—Ç</div>
                <div class="element-button" data-type="corridor">–ö–æ—Ä–∏–¥–æ—Ä</div>
                <div class="element-button" data-type="door">–î–≤–µ—Ä—å</div>
            </div>
        </div>

        <div class="element-list" id="elementList">
            <h3 style="margin-bottom: 10px; padding: 0 15px;">–†–∞–∑–º–µ—â–µ–Ω–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã:</h3>
            <div id="elementsContainer"></div>
        </div>

        <div class="element-properties" id="elementProperties">
            <h3>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —ç–ª–µ–º–µ–Ω—Ç–∞:</h3>
            <div class="control-group" style="border: none; padding: 10px 0;">
                <label>–ü–æ–∑–∏—Ü–∏—è X (px):</label>
                <input type="number" id="elemX" step="1">
            </div>
            <div class="control-group" style="border: none; padding: 10px 0;">
                <label>–ü–æ–∑–∏—Ü–∏—è Y (px):</label>
                <input type="number" id="elemY" step="1">
            </div>
            <div class="control-group" style="border: none; padding: 10px 0;">
                <label>–®–∏—Ä–∏–Ω–∞ (px):</label>
                <input type="number" id="elemWidth" step="1" min="10">
            </div>
            <div class="control-group" style="border: none; padding: 10px 0;">
                <label>–î–ª–∏–Ω–∞ (px):</label>
                <input type="number" id="elemLength" step="1" min="10">
            </div>
            <div class="control-group" style="border: none; padding: 10px 0;">
                <label>–ü—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å:</label>
                <div style="display: flex; gap: 5px;">
                    <input type="number" id="elemCapacity" step="0.1" min="0.1" placeholder="–ê–≤—Ç–æ" style="flex: 1;">
                    <select id="elemCapacityUnit" style="width: 80px;">
                        <option value="second">—á–µ–ª/—Å–µ–∫</option>
                        <option value="minute">—á–µ–ª/–º–∏–Ω</option>
                        <option value="hour">—á–µ–ª/—á–∞—Å</option>
                    </select>
                </div>
                <small style="color: #666; font-size: 11px;">–û—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞—Å—á–µ—Ç–∞</small>
            </div>
            <div class="control-group" style="border: none; padding: 10px 0;">
                <label>–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å (—á–µ–ª/–º¬≤):</label>
                <input type="number" id="elemMaxDensity" step="0.1" min="0.1" value="2.0">
            </div>
            <div class="control-group" style="border: none; padding: 10px 0;">
                <label>–°–æ–µ–¥–∏–Ω–µ–Ω–∏—è:</label>
                <select id="elemConnections" multiple style="height: 80px;">
                    <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è --</option>
                </select>
                <small style="color: #666; font-size: 11px;">–£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ Ctrl –¥–ª—è –≤—ã–±–æ—Ä–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö</small>
            </div>
        </div>
    </div>

    <div class="main-area">
        <div class="toolbar">
            <button class="btn btn-primary" id="runSimulation">‚ñ∂ –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–∏–º—É–ª—è—Ü–∏—é</button>
            <button class="btn btn-primary" id="runAnimation" style="display: none;">‚è∏ –ü–∞—É–∑–∞</button>
            <button class="btn" id="connectMode" title="–†–µ–∂–∏–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤">üîó –°–æ–µ–¥–∏–Ω–∏—Ç—å</button>
            <button class="btn btn-danger" id="clearCanvas">üóë –û—á–∏—Å—Ç–∏—Ç—å</button>
            <button class="btn btn-success" id="saveLayout">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ö–µ–º—É</button>
            <button class="btn" id="loadLayout">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ö–µ–º—É</button>
            <div class="simulation-controls">
                <div class="simulation-info" id="simulationInfo" style="display: none;">
                    –í—Ä–µ–º—è: <span id="currentTime">0</span>—Å | –õ—é–¥–µ–π: <span id="currentPeople">0</span>
                </div>
            </div>
        </div>
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
            </div>
            <div class="results-panel" id="resultsPanel">
                <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è</h2>
                <div id="resultsContent"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let selectedElementType = null;
        let elements = [];
        let selectedElement = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        // –ê–Ω–∏–º–∞—Ü–∏—è
        let people = [];
        let animationData = null;
        let isAnimating = false;
        let animationStartTime = 0;
        let currentSimulationTime = 0;
        let animationId = null;
        let peopleSpawned = 0;
        let connections = []; // –°–æ–µ–¥–∏–Ω–µ–Ω–∏—è –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
        let isConnecting = false;
        let connectingFrom = null;
        
        // –ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è —á–µ–ª–æ–≤–µ–∫–∞
        class Person {
            constructor(id, elementId, startX, startY) {
                this.id = id;
                this.elementId = elementId;
                this.x = startX;
                this.y = startY;
                this.progress = 0; // 0-1 –ø—Ä–æ–≥—Ä–µ—Å—Å —á–µ—Ä–µ–∑ —ç–ª–µ–º–µ–Ω—Ç
                this.speed = 0.02; // —Å–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è
                this.color = `hsl(${Math.random() * 60 + 180}, 70%, 50%)`; // —Å–∏–Ω–∏–µ –æ—Ç—Ç–µ–Ω–∫–∏
                this.size = 4 + Math.random() * 2;
            }
            
            update(element) {
                this.progress += this.speed;
                if (this.progress > 1) {
                    this.progress = 1;
                }
                // –î–≤–∏–∂–µ–Ω–∏–µ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
                this.x = element.x + this.progress * element.length;
                // –ù–µ–±–æ–ª—å—à–æ–µ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –ø–æ Y –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏ (–ª—é–¥–∏ –Ω–µ –∏–¥—É—Ç –∏–¥–µ–∞–ª—å–Ω–æ —Ä–æ–≤–Ω–æ)
                const baseY = element.y + element.width / 2;
                const waveOffset = Math.sin(this.id * 0.1 + this.progress * Math.PI * 2) * element.width * 0.2;
                this.y = baseY + waveOffset;
            }
            
            draw(ctx) {
                ctx.save();
                
                // 3D —á–µ–ª–æ–≤–µ—á–µ–∫ —Å –∏–∑–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–µ–∫—Ü–∏–µ–π
                const height = this.size * 1.5;
                const width = this.size * 0.6;
                const depth = this.size * 0.4;
                
                // –ò–∑–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã
                const isoX = 0.866; // cos(30¬∞)
                const isoY = 0.5;  // sin(30¬∞)
                
                // –¶–µ–Ω—Ç—Ä —Ñ–∏–≥—É—Ä—ã
                const cx = this.x;
                const cy = this.y;
                
                // –†–∏—Å—É–µ–º —Ç–µ–ª–æ (3D –ø–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥)
                // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω—å
                ctx.fillStyle = lightenColor(this.color, 15);
                ctx.beginPath();
                ctx.moveTo(cx, cy - height/2);
                ctx.lineTo(cx + width * isoX, cy - height/2 - width * isoY);
                ctx.lineTo(cx + width * isoX + depth * isoX, cy - height/2 - width * isoY + depth * isoY);
                ctx.lineTo(cx + depth * isoX, cy - height/2 + depth * isoY);
                ctx.closePath();
                ctx.fill();
                
                // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω—å
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(cx + width * isoX, cy - height/2 - width * isoY);
                ctx.lineTo(cx + width * isoX, cy + height/2 - width * isoY);
                ctx.lineTo(cx + width * isoX + depth * isoX, cy + height/2 - width * isoY + depth * isoY);
                ctx.lineTo(cx + width * isoX + depth * isoX, cy - height/2 - width * isoY + depth * isoY);
                ctx.closePath();
                ctx.fill();
                
                // –õ–µ–≤–∞—è –≥—Ä–∞–Ω—å
                ctx.fillStyle = darkenColor(this.color, 15);
                ctx.beginPath();
                ctx.moveTo(cx, cy - height/2);
                ctx.lineTo(cx, cy + height/2);
                ctx.lineTo(cx + width * isoX, cy + height/2 - width * isoY);
                ctx.lineTo(cx + width * isoX, cy - height/2 - width * isoY);
                ctx.closePath();
                ctx.fill();
                
                // –ì–æ–ª–æ–≤–∞ (3D —Å—Ñ–µ—Ä–∞)
                const headSize = this.size * 0.5;
                ctx.fillStyle = lightenColor(this.color, 20);
                // –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å –≥–æ–ª–æ–≤—ã
                ctx.beginPath();
                ctx.ellipse(cx, cy - height/2 - headSize/2, headSize * isoX, headSize * isoY, 0, 0, Math.PI * 2);
                ctx.fill();
                // –ë–æ–∫–æ–≤–∞—è —á–∞—Å—Ç—å
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(cx + headSize * isoX * 0.3, cy - height/2 - headSize/2, headSize * 0.3 * isoX, headSize * isoY, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // –ù–æ–≥–∏ (–¥–≤–µ 3D –∫–æ–ª–æ–Ω–Ω—ã)
                const legWidth = this.size * 0.2;
                const legOffset = this.size * 0.25;
                
                // –õ–µ–≤–∞—è –Ω–æ–≥–∞
                ctx.fillStyle = darkenColor(this.color, 25);
                ctx.beginPath();
                ctx.moveTo(cx - legOffset, cy + height/2);
                ctx.lineTo(cx - legOffset + legWidth * isoX, cy + height/2 - legWidth * isoY);
                ctx.lineTo(cx - legOffset + legWidth * isoX + depth * isoX * 0.5, cy + height/2 - legWidth * isoY + depth * isoY * 0.5);
                ctx.lineTo(cx - legOffset + depth * isoX * 0.5, cy + height/2 + depth * isoY * 0.5);
                ctx.closePath();
                ctx.fill();
                
                // –ü—Ä–∞–≤–∞—è –Ω–æ–≥–∞
                ctx.beginPath();
                ctx.moveTo(cx + legOffset, cy + height/2);
                ctx.lineTo(cx + legOffset + legWidth * isoX, cy + height/2 - legWidth * isoY);
                ctx.lineTo(cx + legOffset + legWidth * isoX + depth * isoX * 0.5, cy + height/2 - legWidth * isoY + depth * isoY * 0.5);
                ctx.lineTo(cx + legOffset + depth * isoX * 0.5, cy + height/2 + depth * isoY * 0.5);
                ctx.closePath();
                ctx.fill();
                
                // –¢–µ–Ω—å –ø–æ–¥ –Ω–æ–≥–∞–º–∏
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(cx, cy + height/2 + 3, this.size * 0.8, this.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ canvas
        function resizeCanvas() {
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–æ–ª—å—à–æ–π —Ä–∞–∑–º–µ—Ä –¥–ª—è —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
            canvas.width = Math.max(canvas.offsetWidth || 2000, 2000);
            canvas.height = Math.max(canvas.offsetHeight || 1500, 1500);
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ä–∞—Å—Ç—è–≥–∏–≤–∞–Ω–∏—è
        let isResizing = false;
        let resizeHandle = null;
        let resizeStartPos = { x: 0, y: 0 };
        let resizeStartSize = { width: 0, length: 0 };

        // –ü–∞–ª–∏—Ç—Ä–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        document.querySelectorAll('.element-button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.element-button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedElementType = btn.dataset.type;
                canvas.style.cursor = 'crosshair';
                isConnecting = false;
                document.getElementById('connectMode').classList.remove('active');
            });
        });
        
        // –†–µ–∂–∏–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        document.getElementById('connectMode').addEventListener('click', () => {
            isConnecting = !isConnecting;
            selectedElementType = null;
            document.querySelectorAll('.element-button').forEach(b => b.classList.remove('active'));
            if (isConnecting) {
                document.getElementById('connectMode').classList.add('active');
                canvas.style.cursor = 'crosshair';
            } else {
                document.getElementById('connectMode').classList.remove('active');
                canvas.style.cursor = 'default';
            }
        });

        // –†–∞–∑–º–µ—â–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞ canvas (drag to create)
        let isCreating = false;
        let createStart = { x: 0, y: 0 };
        
        // –í—ã–±–æ—Ä –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —Ç–∏–ø —ç–ª–µ–º–µ–Ω—Ç–∞ - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
            if (selectedElementType) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∫–ª–∏–∫–Ω—É–ª–∏ –ª–∏ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç
                let clickedOnElement = false;
                for (let i = elements.length - 1; i >= 0; i--) {
                    const elem = elements[i];
                    if (x >= elem.x && x <= elem.x + elem.length && 
                        y >= elem.y && y <= elem.y + elem.width) {
                        clickedOnElement = true;
                        break;
                    }
                }
                
                if (!clickedOnElement) {
                    isCreating = true;
                    createStart = { x, y };
                }
                return;
            }
            
            // –ï—Å–ª–∏ —Ä–µ–∂–∏–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            if (isConnecting) {
                // –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
                for (let i = elements.length - 1; i >= 0; i--) {
                    const elem = elements[i];
                    if (x >= elem.x && x <= elem.x + elem.length && 
                        y >= elem.y && y <= elem.y + elem.width) {
                        if (!connectingFrom) {
                            // –ù–∞—á–∞–ª–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                            connectingFrom = elem.id;
                            selectedElement = elem;
                            updateElementList();
                            draw();
                        } else if (connectingFrom !== elem.id) {
                            // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                            const existing = connections.find(c => 
                                (c.from === connectingFrom && c.to === elem.id) ||
                                (c.to === connectingFrom && c.from === elem.id)
                            );
                            if (!existing) {
                                connections.push({
                                    from: connectingFrom,
                                    to: elem.id
                                });
                                updateConnectionsList();
                            }
                            connectingFrom = null;
                            draw();
                        }
                        return;
                    }
                }
                // –ï—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–µ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                if (connectingFrom) {
                    connectingFrom = null;
                    draw();
                }
                return;
            }
            
            // –ò–Ω–∞—á–µ - –≤—ã–±–∏—Ä–∞–µ–º/–ø–µ—Ä–µ–º–µ—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –Ω–∞ resize handle
            if (selectedElement) {
                const elem = selectedElement;
                const handles = [
                    { x: elem.x + elem.length, y: elem.y + elem.width, corner: 'se' },
                    { x: elem.x, y: elem.y + elem.width, corner: 'sw' },
                    { x: elem.x + elem.length, y: elem.y, corner: 'ne' },
                    { x: elem.x, y: elem.y, corner: 'nw' }
                ];
                
                for (let handle of handles) {
                    const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                    if (dist < 15) {
                        isResizing = true;
                        resizeHandle = handle.corner;
                        resizeStartPos = { x, y };
                        resizeStartSize = { width: elem.width, length: elem.length };
                        return;
                    }
                }
            }

            selectedElement = null;
            for (let i = elements.length - 1; i >= 0; i--) {
                const elem = elements[i];
                if (x >= elem.x && x <= elem.x + elem.length && 
                    y >= elem.y && y <= elem.y + elem.width) {
                    selectedElement = elem;
                    isDragging = true;
                    dragOffset.x = x - elem.x;
                    dragOffset.y = y - elem.y;
                    updateElementList();
                    draw();
                    showElementProperties(elem);
                    break;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            canvas.mouseX = e.clientX - rect.left;
            canvas.mouseY = e.clientY - rect.top;
            
            if (isCreating && selectedElementType) {
                const x = canvas.mouseX;
                const y = canvas.mouseY;
                
                // –í—Ä–µ–º–µ–Ω–Ω–æ —Ä–∏—Å—É–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏
                draw();
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const width = Math.abs(y - createStart.y);
                const length = Math.abs(x - createStart.x);
                ctx.strokeRect(
                    Math.min(createStart.x, x),
                    Math.min(createStart.y, y),
                    length || getDefaultLength(selectedElementType),
                    width || getDefaultWidth(selectedElementType)
                );
                ctx.setLineDash([]);
                return;
            }
            
            if (isResizing && selectedElement) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const dx = x - resizeStartPos.x;
                const dy = y - resizeStartPos.y;
                
                if (resizeHandle === 'se') {
                    selectedElement.length = Math.max(20, resizeStartSize.length + dx);
                    selectedElement.width = Math.max(10, resizeStartSize.width + dy);
                } else if (resizeHandle === 'sw') {
                    selectedElement.length = Math.max(20, resizeStartSize.length - dx);
                    selectedElement.width = Math.max(10, resizeStartSize.width + dy);
                    selectedElement.x = resizeStartPos.x - (selectedElement.length - resizeStartSize.length);
                } else if (resizeHandle === 'ne') {
                    selectedElement.length = Math.max(20, resizeStartSize.length + dx);
                    selectedElement.width = Math.max(10, resizeStartSize.width - dy);
                    selectedElement.y = resizeStartPos.y - (selectedElement.width - resizeStartSize.width);
                } else if (resizeHandle === 'nw') {
                    selectedElement.length = Math.max(20, resizeStartSize.length - dx);
                    selectedElement.width = Math.max(10, resizeStartSize.width - dy);
                    selectedElement.x = resizeStartPos.x - (selectedElement.length - resizeStartSize.length);
                    selectedElement.y = resizeStartPos.y - (selectedElement.width - resizeStartSize.width);
                }
                
                updateElementPropertiesInputs();
                draw();
            } else if (isDragging && selectedElement) {
                const rect = canvas.getBoundingClientRect();
                selectedElement.x = e.clientX - rect.left - dragOffset.x;
                selectedElement.y = e.clientY - rect.top - dragOffset.y;
                updateElementPropertiesInputs();
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isCreating && selectedElementType) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const element = {
                    id: 'elem_' + Date.now(),
                    type: selectedElementType,
                    x: Math.min(createStart.x, x),
                    y: Math.min(createStart.y, y),
                    width: Math.max(Math.abs(y - createStart.y), getDefaultWidth(selectedElementType)),
                    length: Math.max(Math.abs(x - createStart.x), getDefaultLength(selectedElementType)),
                    capacity_per_second: null, // –±—É–¥–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                    capacity_unit: 'second',
                    max_density: 2.0
                };

                elements.push(element);
                selectedElement = element;
                updateElementList();
                showElementProperties(element);
                draw();
                isCreating = false;
            }
            
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
        });

        // –£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' && selectedElement) {
                elements = elements.filter(e => e.id !== selectedElement.id);
                selectedElement = null;
                document.getElementById('elementProperties').classList.remove('visible');
                updateElementList();
                draw();
            }
        });

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ —ç–ª–µ–º–µ–Ω—Ç–∞
        function updateElementPropertiesInputs() {
            if (!selectedElement) return;
            document.getElementById('elemX').value = Math.round(selectedElement.x);
            document.getElementById('elemY').value = Math.round(selectedElement.y);
            document.getElementById('elemWidth').value = Math.round(selectedElement.width);
            document.getElementById('elemLength').value = Math.round(selectedElement.length);
            
            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –ø—Ä–æ–ø—É—Å–∫–Ω—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –≤ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –µ–¥–∏–Ω–∏—Ü—ã
            const capacity = selectedElement.capacity_per_second || null;
            const unit = selectedElement.capacity_unit || 'second';
            if (capacity !== null) {
                let displayValue = capacity;
                if (unit === 'minute') displayValue = capacity * 60;
                else if (unit === 'hour') displayValue = capacity * 3600;
                document.getElementById('elemCapacity').value = displayValue;
            } else {
                document.getElementById('elemCapacity').value = '';
            }
            document.getElementById('elemCapacityUnit').value = unit;
            
            document.getElementById('elemMaxDensity').value = selectedElement.max_density || 2.0;
            updateConnectionsList();
        }
        
        document.getElementById('elemX').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.x = parseFloat(e.target.value) || 0;
                draw();
            }
        });
        
        document.getElementById('elemY').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.y = parseFloat(e.target.value) || 0;
                draw();
            }
        });

        document.getElementById('elemWidth').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.width = Math.max(10, parseFloat(e.target.value) || 10);
                draw();
            }
        });

        document.getElementById('elemLength').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.length = Math.max(20, parseFloat(e.target.value) || 20);
                draw();
            }
        });
        
        document.getElementById('elemCapacity').addEventListener('input', (e) => {
            if (selectedElement) {
                updateCapacityFromInput();
            }
        });
        
        document.getElementById('elemCapacityUnit').addEventListener('change', (e) => {
            if (selectedElement) {
                selectedElement.capacity_unit = e.target.value;
                updateCapacityFromInput();
            }
        });
        
        function updateCapacityFromInput() {
            if (!selectedElement) return;
            const value = document.getElementById('elemCapacity').value.trim();
            const unit = document.getElementById('elemCapacityUnit').value;
            
            if (value && !isNaN(value)) {
                let capacityValue = parseFloat(value);
                if (capacityValue > 0) {
                    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —á–µ–ª/—Å–µ–∫ –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è
                    if (unit === 'minute') capacityValue = capacityValue / 60;
                    else if (unit === 'hour') capacityValue = capacityValue / 3600;
                    selectedElement.capacity_per_second = capacityValue;
                    selectedElement.capacity_unit = unit;
                    draw(); // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                } else {
                    selectedElement.capacity_per_second = null;
                }
            } else {
                selectedElement.capacity_per_second = null;
            }
        }
        
        document.getElementById('elemMaxDensity').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.max_density = parseFloat(e.target.value) || 2.0;
            }
        });
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
        function updateConnectionsList() {
            const select = document.getElementById('elemConnections');
            select.innerHTML = '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è --</option>';
            elements.forEach(elem => {
                if (elem.id !== selectedElement?.id) {
                    const option = document.createElement('option');
                    option.value = elem.id;
                    option.textContent = getElementName(elem.type) + ` (${elem.id})`;
                    if (selectedElement && connections.some(c => 
                        (c.from === selectedElement.id && c.to === elem.id) ||
                        (c.to === selectedElement.id && c.from === elem.id)
                    )) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                }
            });
        }
        
        document.getElementById('elemConnections').addEventListener('change', (e) => {
            if (!selectedElement) return;
            
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –¥–ª—è —ç—Ç–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
            connections = connections.filter(c => 
                c.from !== selectedElement.id && c.to !== selectedElement.id
            );
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            Array.from(e.target.selectedOptions).forEach(option => {
                if (option.value) {
                    connections.push({
                        from: selectedElement.id,
                        to: option.value
                    });
                }
            });
            
            draw();
        });

        // –ó–∞–ø—É—Å–∫ —Å–∏–º—É–ª—è—Ü–∏–∏ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
        document.getElementById('runSimulation').addEventListener('click', async () => {
            if (elements.length === 0) {
                alert('–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ —Å—Ö–µ–º—É');
                return;
            }

            const peopleCount = parseInt(document.getElementById('peopleCount').value);
            const simulationTime = parseInt(document.getElementById('simulationTime').value);

            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –∞–Ω–∏–º–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å
            if (isAnimating) {
                stopAnimation();
            }

            try {
                // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
                const animResponse = await fetch('/api/animation/prepare', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        elements: elements,
                        people_count: peopleCount,
                        simulation_time: simulationTime
                    })
                });
                animationData = await animResponse.json();
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
                startAnimation(peopleCount, simulationTime);
                
                // –¢–∞–∫–∂–µ –ø–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –ø–∞–Ω–µ–ª–∏
                const response = await fetch('/api/simulate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        elements: elements,
                        people_count: peopleCount,
                        simulation_time: simulationTime
                    })
                });

                const result = await response.json();
                showResults(result);
            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Å–∏–º—É–ª—è—Ü–∏–∏: ' + error.message);
            }
        });
        
        // –ö–Ω–æ–ø–∫–∞ –ø–∞—É–∑—ã/–≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        document.getElementById('runAnimation').addEventListener('click', () => {
            if (isAnimating) {
                stopAnimation();
            } else {
                resumeAnimation();
            }
        });
        
        function startAnimation(peopleCount, simulationTime) {
            people = [];
            peopleSpawned = 0;
            currentSimulationTime = 0;
            animationStartTime = Date.now();
            isAnimating = true;
            
            document.getElementById('runSimulation').style.display = 'none';
            document.getElementById('runAnimation').style.display = 'inline-block';
            document.getElementById('simulationInfo').style.display = 'block';
            
            animate();
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            document.getElementById('runAnimation').textContent = '‚ñ∂ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å';
        }
        
        function resumeAnimation() {
            isAnimating = true;
            animationStartTime = Date.now() - currentSimulationTime * 1000;
            document.getElementById('runAnimation').textContent = '‚è∏ –ü–∞—É–∑–∞';
            animate();
        }
        
        function animate() {
            if (!isAnimating || !animationData) return;
            
            const now = Date.now();
            const elapsed = (now - animationStartTime) / 1000; // —Å–µ–∫—É–Ω–¥—ã
            currentSimulationTime = elapsed;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            document.getElementById('currentTime').textContent = Math.floor(currentSimulationTime);
            document.getElementById('currentPeople').textContent = people.length;
            
            // –°–ø–∞–≤–Ω–∏–º –Ω–æ–≤—ã—Ö –ª—é–¥–µ–π
            if (animationData && animationData.elements) {
                animationData.elements.forEach(elemData => {
                    const element = elements.find(e => e.id === elemData.id);
                    if (!element) return;
                    
                    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ–ª—å–∫–æ –ª—é–¥–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ —ç–ª–µ–º–µ–Ω—Ç–µ
                    const targetCount = Math.min(
                        Math.floor(elemData.capacity_per_second * currentSimulationTime),
                        peopleSpawned < animationData.people_count ? animationData.people_count - peopleSpawned : 0
                    );
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –ª—é–¥–µ–π –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                    const currentInElement = people.filter(p => p.elementId === elemData.id).length;
                    if (currentInElement < targetCount && peopleSpawned < animationData.people_count) {
                        const toAdd = Math.min(targetCount - currentInElement, 10); // –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ 10 –∑–∞ —Ä–∞–∑ –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
                        for (let i = 0; i < toAdd; i++) {
                            const person = new Person(
                                peopleSpawned++,
                                elemData.id,
                                element.x - 5, // –Ω–∞—á–∏–Ω–∞–µ–º –Ω–µ–º–Ω–æ–≥–æ –ª–µ–≤–µ–µ —ç–ª–µ–º–µ–Ω—Ç–∞
                                element.y + (Math.random() - 0.5) * element.width * 0.8 + element.width / 2
                            );
                            // –°–∫–æ—Ä–æ—Å—Ç—å –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ø—Ä–æ–ø—É—Å–∫–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç–∞
                            person.speed = 0.008 + (elemData.capacity_per_second / 200);
                            // –ù–µ–±–æ–ª—å—à–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏
                            person.speed *= (0.8 + Math.random() * 0.4);
                            people.push(person);
                        }
                    }
                });
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –ª—é–¥–µ–π
            people.forEach(person => {
                const element = elements.find(e => e.id === person.elementId);
                if (element) {
                    person.update(element);
                    // –ï—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –ø—Ä–æ—à–µ–ª —ç–ª–µ–º–µ–Ω—Ç, —É–¥–∞–ª—è–µ–º –µ–≥–æ –∏–ª–∏ –ø–µ—Ä–µ–º–µ—â–∞–µ–º –≤ —Å–ª–µ–¥—É—é—â–∏–π
                    if (person.progress >= 1) {
                        const index = people.indexOf(person);
                        if (index > -1) {
                            people.splice(index, 1);
                        }
                    }
                }
            });
            
            draw();
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
            if (currentSimulationTime >= animationData.total_time && people.length === 0) {
                stopAnimation();
                document.getElementById('runSimulation').style.display = 'inline-block';
                document.getElementById('runAnimation').style.display = 'none';
                return;
            }
            
            animationId = requestAnimationFrame(animate);
        }

        // –û—á–∏—Å—Ç–∫–∞ canvas
        document.getElementById('clearCanvas').addEventListener('click', () => {
            if (confirm('–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—é —Å—Ö–µ–º—É?')) {
                if (isAnimating) {
                    stopAnimation();
                }
                elements = [];
                people = [];
                connections = [];
                selectedElement = null;
                animationData = null;
                connectingFrom = null;
                document.getElementById('elementProperties').classList.remove('visible');
                document.getElementById('simulationInfo').style.display = 'none';
                document.getElementById('runSimulation').style.display = 'inline-block';
                document.getElementById('runAnimation').style.display = 'none';
                updateElementList();
                draw();
            }
        });

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ/–∑–∞–≥—Ä—É–∑–∫–∞
        document.getElementById('saveLayout').addEventListener('click', () => {
            const data = JSON.stringify({
                elements: elements,
                connections: connections
            }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'layout.json';
            a.click();
        });

        document.getElementById('loadLayout').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = JSON.parse(e.target.result);
                    elements = data.elements || data;
                    connections = data.connections || [];
                    updateElementList();
                    draw();
                };
                reader.readAsText(file);
            };
            input.click();
        });

        // –§—É–Ω–∫—Ü–∏–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // –°–µ—Ç–∫–∞
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // –≠–ª–µ–º–µ–Ω—Ç—ã —Å 3D —ç—Ñ—Ñ–µ–∫—Ç–æ–º –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
            elements.forEach(elem => {
                const isSelected = elem === selectedElement;
                
                // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–ª–æ—Ç–Ω–æ—Å—Ç—å –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–∞—Ç–æ—Ä–æ–≤
                const peopleInElement = people.filter(p => p.elementId === elem.id);
                // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞–∑–º–µ—Ä–∞
                const area_m2 = (elem.width * 0.1) * (elem.length * 0.1);
                const maxDensity = elem.max_density || 2.0;
                const maxCapacity = area_m2 * maxDensity;
                const density = maxCapacity > 0 ? peopleInElement.length / maxCapacity : 0;
                const densityPercent = Math.min(density * 100, 100);
                
                // –¶–≤–µ—Ç –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ (–∑–∞—Ç–æ—Ä—ã)
                let color = isSelected ? '#3498db' : getElementColor(elem.type);
                if (isAnimating && density > 0.7) {
                    // –ö—Ä–∞—Å–Ω—ã–π –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
                    color = '#e74c3c';
                } else if (isAnimating && density > 0.4) {
                    // –û—Ä–∞–Ω–∂–µ–≤—ã–π –ø—Ä–∏ —Å—Ä–µ–¥–Ω–µ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
                    color = '#f39c12';
                }
                
                // –†–∏—Å—É–µ–º –æ—Å–Ω–æ–≤—É —ç–ª–µ–º–µ–Ω—Ç–∞ (–ø–ª–æ—Å–∫–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å)
                ctx.fillStyle = color;
                ctx.strokeStyle = isSelected ? '#2980b9' : darkenColor(color, 30);
                ctx.lineWidth = isSelected ? 3 : 2;
                drawRoundedRect(ctx, elem.x, elem.y, elem.length, elem.width, 4);
                ctx.fill();
                ctx.stroke();
                
                // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ (–æ–≤–µ—Ä–ª–µ–π)
                if (isAnimating && density > 0) {
                    ctx.fillStyle = density > 0.7 ? 'rgba(231, 76, 60, 0.4)' : 
                                   density > 0.4 ? 'rgba(243, 156, 18, 0.4)' : 
                                   'rgba(39, 174, 96, 0.3)';
                    drawRoundedRect(ctx, elem.x, elem.y, elem.length, elem.width, 4);
                    ctx.fill();
                    
                    // –¢–µ–∫—Å—Ç —Å –ø–ª–æ—Ç–Ω–æ—Å—Ç—å—é
                    ctx.fillStyle = density > 0.7 ? '#fff' : '#333';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        `${Math.round(densityPercent)}%`,
                        elem.x + elem.length / 2,
                        elem.y + 18
                    );
                }

                // –†–∏—Å—É–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
                drawElementVisualization(ctx, elem);
                
                // –¢–µ–∫—Å—Ç –Ω–∞–∑–≤–∞–Ω–∏—è —Å —Ñ–æ–Ω–æ–º –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
                const textX = elem.x + elem.length / 2;
                const textY = elem.y + elem.width / 2;
                
                // –§–æ–Ω –¥–ª—è —Ç–µ–∫—Å—Ç–∞
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(textX - 40, textY - 10, 80, 20);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 13px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    getElementName(elem.type),
                    textX,
                    textY
                );
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–ø—É—Å–∫–Ω—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –µ—Å–ª–∏ –∑–∞–¥–∞–Ω–∞
                if (elem.capacity_per_second) {
                    const unit = elem.capacity_unit || 'second';
                    let displayValue = elem.capacity_per_second;
                    let unitText = '—á–µ–ª/—Å–µ–∫';
                    if (unit === 'minute') {
                        displayValue = elem.capacity_per_second * 60;
                        unitText = '—á–µ–ª/–º–∏–Ω';
                    } else if (unit === 'hour') {
                        displayValue = elem.capacity_per_second * 3600;
                        unitText = '—á–µ–ª/—á–∞—Å';
                    }
                    
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(elem.x + 5, elem.y + elem.width - 20, 100, 16);
                    ctx.fillStyle = '#fff';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(
                        `${displayValue.toFixed(1)} ${unitText}`,
                        elem.x + 8,
                        elem.y + elem.width - 8
                    );
                }
                
                // Resize handles –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                if (isSelected && !isAnimating) {
                    ctx.fillStyle = '#3498db';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    const handles = [
                        { x: elem.x + elem.length, y: elem.y + elem.width },
                        { x: elem.x, y: elem.y + elem.width },
                        { x: elem.x + elem.length, y: elem.y },
                        { x: elem.x, y: elem.y }
                    ];
                    handles.forEach(handle => {
                        ctx.beginPath();
                        ctx.arc(handle.x, handle.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    });
                }
            });
            
            // –†–∏—Å—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
            drawConnections(ctx);
            
            // –†–∏—Å—É–µ–º –ª—é–¥–µ–π
            people.forEach(person => {
                person.draw(ctx);
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–µ–∫—Ü–∏–∏
        function isoProject(x, y, z) {
            const isoX = 0.866; // cos(30¬∞)
            const isoY = 0.5;  // sin(30¬∞)
            return {
                x: x * isoX - y * isoX,
                y: x * isoY + y * isoY - z
            };
        }
        
        function draw3DBox(ctx, x, y, width, length, height, color) {
            const isoX = 0.866;
            const isoY = 0.5;
            const depth = height * 0.3;
            
            // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω—å
            ctx.fillStyle = lightenColor(color, 20);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + length * isoX, y - length * isoY);
            ctx.lineTo(x + length * isoX + width * isoX, y - length * isoY - width * isoY);
            ctx.lineTo(x + width * isoX, y - width * isoY);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = darkenColor(color, 20);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω—å
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + length * isoX, y - length * isoY);
            ctx.lineTo(x + length * isoX, y - length * isoY - depth);
            ctx.lineTo(x + length * isoX + width * isoX, y - length * isoY - width * isoY - depth);
            ctx.lineTo(x + length * isoX + width * isoX, y - length * isoY - width * isoY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // –õ–µ–≤–∞—è –≥—Ä–∞–Ω—å
            ctx.fillStyle = darkenColor(color, 15);
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - depth);
            ctx.lineTo(x + length * isoX, y - length * isoY - depth);
            ctx.lineTo(x + length * isoX, y - length * isoY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function drawElementVisualization(ctx, elem) {
            ctx.save();
            
            const centerX = elem.x + elem.length / 2;
            const centerY = elem.y + elem.width / 2;
            
            switch(elem.type) {
                case 'escalator':
                    // –≠—Å–∫–∞–ª–∞—Ç–æ—Ä - —á–µ—Ç–∫–∏–µ —Å—Ç—É–ø–µ–Ω–∏ –∏ –ø–æ—Ä—É—á–Ω–∏
                    ctx.strokeStyle = '#fff';
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.lineWidth = 2;
                    
                    // –†–∏—Å—É–µ–º —Å—Ç—É–ø–µ–Ω–∏
                    const stepCount = Math.max(5, Math.floor(elem.length / 25));
                    for (let i = 0; i < stepCount; i++) {
                        const stepX = elem.x + (i / stepCount) * elem.length;
                        const stepWidth = elem.length / stepCount;
                        const stepHeight = 4;
                        
                        // –°—Ç—É–ø–µ–Ω—å
                        ctx.fillRect(stepX, elem.y + 2, stepWidth - 2, stepHeight);
                        ctx.strokeRect(stepX, elem.y + 2, stepWidth - 2, stepHeight);
                        
                        // –õ–∏–Ω–∏—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è —Å—Ç—É–ø–µ–Ω–µ–π
                        ctx.beginPath();
                        ctx.moveTo(stepX + stepWidth - 2, elem.y + 2);
                        ctx.lineTo(stepX + stepWidth - 2, elem.y + 2 + stepHeight);
                        ctx.stroke();
                    }
                    
                    // –ü–æ—Ä—É—á–Ω–∏ (–¥–≤–µ –ª–∏–Ω–∏–∏ –ø–æ –±–æ–∫–∞–º)
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y);
                    ctx.lineTo(elem.x + elem.length, elem.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y + elem.width);
                    ctx.lineTo(elem.x + elem.length, elem.y + elem.width);
                    ctx.stroke();
                    
                    // –°—Ç—Ä–µ–ª–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(elem.x + elem.length - 25, centerY - 6);
                    ctx.lineTo(elem.x + elem.length - 8, centerY);
                    ctx.lineTo(elem.x + elem.length - 25, centerY + 6);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'stairs':
                    // –õ–µ—Å—Ç–Ω–∏—Ü–∞ - —á–µ—Ç–∫–∏–µ —Å—Ç—É–ø–µ–Ω–∏
                    ctx.strokeStyle = '#fff';
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.lineWidth = 2;
                    
                    const stairsCount = Math.max(3, Math.floor(elem.length / 20));
                    const stepHeight = elem.width / stairsCount;
                    
                    for (let i = 0; i < stairsCount; i++) {
                        const stepY = elem.y + i * stepHeight;
                        const stepWidth = elem.length;
                        
                        // –°—Ç—É–ø–µ–Ω—å
                        ctx.fillRect(elem.x, stepY, stepWidth, stepHeight - 1);
                        ctx.strokeRect(elem.x, stepY, stepWidth, stepHeight - 1);
                        
                        // –ü–µ—Ä–µ–¥–Ω—è—è –≥—Ä–∞–Ω—å —Å—Ç—É–ø–µ–Ω–∏ (—Ç–µ–º–Ω–µ–µ)
                        ctx.fillStyle = darkenColor('#e67e22', 30);
                        ctx.fillRect(elem.x, stepY + stepHeight - 1, stepWidth, 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    }
                    
                    // –ü–µ—Ä–∏–ª–∞
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y);
                    ctx.lineTo(elem.x + elem.length, elem.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y + elem.width);
                    ctx.lineTo(elem.x + elem.length, elem.y + elem.width);
                    ctx.stroke();
                    break;
                    
                case 'turnstile':
                    // –¢—É—Ä–Ω–∏–∫–µ—Ç - —Ä–∏—Å—É–µ–º –≤—Ä–∞—â–∞—é—â–∏–µ—Å—è –ø–ª–∞–Ω–∫–∏
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    const centerX = elem.x + elem.length / 2;
                    const centerY = elem.y + elem.width / 2;
                    const radius = Math.min(elem.length, elem.width) / 2 - 5;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    // –ü–ª–∞–Ω–∫–∏
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI * 2) / 4;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(
                            centerX + Math.cos(angle) * radius,
                            centerY + Math.sin(angle) * radius
                        );
                        ctx.stroke();
                    }
                    break;
                    
                case 'door':
                    // –î–≤–µ—Ä—å - —Ä–∏—Å—É–µ–º –¥–≤–µ—Ä–Ω—É—é —Ä–∞–º—É –∏ —Å—Ç–≤–æ—Ä–∫–∏
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    // –†–∞–º–∞
                    ctx.strokeRect(elem.x + 2, elem.y + 2, elem.length - 4, elem.width - 4);
                    // –°—Ç–≤–æ—Ä–∫–∏
                    ctx.beginPath();
                    ctx.moveTo(elem.x + elem.length / 2, elem.y);
                    ctx.lineTo(elem.x + elem.length / 2, elem.y + elem.width);
                    ctx.stroke();
                    // –†—É—á–∫–∞
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(elem.x + elem.length / 2 - 5, elem.y + elem.width / 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'tunnel':
                    // –¢–æ–Ω–Ω–µ–ª—å - –∞—Ä–∫–∏
                    ctx.strokeStyle = '#fff';
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.lineWidth = 3;
                    
                    const archCount = Math.max(2, Math.floor(elem.length / 60));
                    const archRadius = elem.width / 2;
                    
                    for (let i = 0; i <= archCount; i++) {
                        const archX = elem.x + (i / archCount) * elem.length;
                        const archCenterY = elem.y + elem.width / 2;
                        
                        // –ê—Ä–∫–∞ (–ø–æ–ª—É–∫—Ä—É–≥)
                        ctx.beginPath();
                        ctx.arc(archX, archCenterY, archRadius, Math.PI, 0, false);
                        ctx.stroke();
                        
                        // –ó–∞–ª–∏–≤–∫–∞ –∞—Ä–∫–∏
                        ctx.beginPath();
                        ctx.arc(archX, archCenterY, archRadius, Math.PI, 0, false);
                        ctx.fill();
                    }
                    
                    // –ü–æ–ª (–ª–∏–Ω–∏—è)
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y + elem.width);
                    ctx.lineTo(elem.x + elem.length, elem.y + elem.width);
                    ctx.stroke();
                    break;
                    
                case 'corridor':
                    // –ö–æ—Ä–∏–¥–æ—Ä - —Å—Ç–µ–Ω—ã –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    
                    // –í–µ—Ä—Ö–Ω—è—è —Å—Ç–µ–Ω–∞
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y);
                    ctx.lineTo(elem.x + elem.length, elem.y);
                    ctx.stroke();
                    
                    // –ù–∏–∂–Ω—è—è —Å—Ç–µ–Ω–∞
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y + elem.width);
                    ctx.lineTo(elem.x + elem.length, elem.y + elem.width);
                    ctx.stroke();
                    
                    // –õ–∏–Ω–∏–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (—Å—Ç—Ä–µ–ª–∫–∏)
                    ctx.strokeStyle = '#fff';
                    ctx.fillStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([20, 10]);
                    ctx.beginPath();
                    ctx.moveTo(elem.x + 10, centerY);
                    ctx.lineTo(elem.x + elem.length - 10, centerY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // –°—Ç—Ä–µ–ª–∫–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                    const arrowCount = Math.floor(elem.length / 40);
                    for (let i = 1; i < arrowCount; i++) {
                        const arrowX = elem.x + (i / arrowCount) * elem.length;
                        ctx.beginPath();
                        ctx.moveTo(arrowX, centerY - 5);
                        ctx.lineTo(arrowX + 8, centerY);
                        ctx.lineTo(arrowX, centerY + 5);
                        ctx.closePath();
                        ctx.fill();
                    }
                    break;
            }
            
            ctx.restore();
        }
        
        function drawConnections(ctx) {
            connections.forEach(conn => {
                const from = elements.find(e => e.id === conn.from);
                const to = elements.find(e => e.id === conn.to);
                if (!from || !to) return;
                
                // –¢–æ—á–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è (–≤—ã—Ö–æ–¥ –∏ –≤—Ö–æ–¥)
                const fromPoint = {
                    x: from.x + from.length,
                    y: from.y + from.width / 2
                };
                const toPoint = {
                    x: to.x,
                    y: to.y + to.width / 2
                };
                
                // –õ–∏–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(fromPoint.x, fromPoint.y);
                ctx.lineTo(toPoint.x, toPoint.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // –°—Ç—Ä–µ–ª–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                const angle = Math.atan2(toPoint.y - fromPoint.y, toPoint.x - fromPoint.x);
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.moveTo(toPoint.x - 10, toPoint.y);
                ctx.lineTo(toPoint.x - 10 - 8 * Math.cos(angle - Math.PI / 6), toPoint.y - 8 * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(toPoint.x - 10 - 8 * Math.cos(angle + Math.PI / 6), toPoint.y - 8 * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
                
                // –¢–æ—á–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(fromPoint.x, fromPoint.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(toPoint.x, toPoint.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // –ï—Å–ª–∏ —Å–æ–∑–¥–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
            if (isConnecting && connectingFrom) {
                const from = elements.find(e => e.id === connectingFrom);
                if (from) {
                    const fromPoint = {
                        x: from.x + from.length,
                        y: from.y + from.width / 2
                    };
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(fromPoint.x, fromPoint.y);
                    ctx.lineTo(canvas.mouseX || fromPoint.x, canvas.mouseY || fromPoint.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function getElementColor(type) {
            const colors = {
                tunnel: '#95a5a6',
                stairs: '#e67e22',
                escalator: '#9b59b6',
                turnstile: '#e74c3c',
                corridor: '#3498db',
                door: '#f39c12'
            };
            return colors[type] || '#95a5a6';
        }

        function getElementName(type) {
            const names = {
                tunnel: '–¢–æ–Ω–Ω–µ–ª—å',
                stairs: '–õ–µ—Å—Ç–Ω–∏—Ü–∞',
                escalator: '–≠—Å–∫–∞–ª–∞—Ç–æ—Ä',
                turnstile: '–¢—É—Ä–Ω–∏–∫–µ—Ç',
                corridor: '–ö–æ—Ä–∏–¥–æ—Ä',
                door: '–î–≤–µ—Ä—å'
            };
            return names[type] || type;
        }

        function getDefaultWidth(type) {
            const defaults = {
                tunnel: 80,
                stairs: 40,
                escalator: 30,
                turnstile: 30,
                corridor: 60,
                door: 40
            };
            return defaults[type] || 50;
        }

        function getDefaultLength(type) {
            const defaults = {
                tunnel: 300,
                stairs: 150,
                escalator: 200,
                turnstile: 30,
                corridor: 200,
                door: 20
            };
            return defaults[type] || 150;
        }

        function updateElementList() {
            const container = document.getElementById('elementsContainer');
            container.innerHTML = '';
            
            elements.forEach(elem => {
                const div = document.createElement('div');
                div.className = 'element-item' + (elem === selectedElement ? ' selected' : '');
                div.innerHTML = `
                    <span>${getElementName(elem.type)}</span>
                    <button class="delete-btn" onclick="deleteElement('${elem.id}')">–£–¥–∞–ª–∏—Ç—å</button>
                `;
                div.onclick = () => {
                    selectedElement = elem;
                    updateElementList();
                    showElementProperties(elem);
                    draw();
                };
                container.appendChild(div);
            });
        }

        function deleteElement(id) {
            elements = elements.filter(e => e.id !== id);
            // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —ç—Ç–∏–º —ç–ª–µ–º–µ–Ω—Ç–æ–º
            connections = connections.filter(c => c.from !== id && c.to !== id);
            if (selectedElement && selectedElement.id === id) {
                selectedElement = null;
                document.getElementById('elementProperties').classList.remove('visible');
            }
            if (connectingFrom === id) {
                connectingFrom = null;
            }
            updateElementList();
            draw();
        }

        function showElementProperties(elem) {
            document.getElementById('elementProperties').classList.add('visible');
            updateElementPropertiesInputs();
            updateConnectionsList();
        }

        function showResults(result) {
            const panel = document.getElementById('resultsPanel');
            const content = document.getElementById('resultsContent');
            
            if (result.error) {
                content.innerHTML = `<div class="result-item"><p style="color: red;">${result.error}</p></div>`;
            } else {
                let html = `
                    <div class="result-item">
                        <h3>–û–±—â–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã</h3>
                        <p><strong>–í—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è:</strong> ${result.total_time} —Å–µ–∫ (${(result.total_time / 60).toFixed(1)} –º–∏–Ω)</p>
                        <p><strong>–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –ª—é–¥–µ–π:</strong> ${result.people_processed} –∏–∑ ${result.people_count}</p>
                        <p><strong>–£–∑–∫–æ–µ –º–µ—Å—Ç–æ:</strong> ${result.bottleneck.name}</p>
                    </div>
                `;

                result.elements.forEach(elem => {
                    html += `
                        <div class="result-item ${elem.is_bottleneck ? 'bottleneck' : ''}">
                            <h3>${elem.name} ${elem.is_bottleneck ? '(–£–∑–∫–æ–µ –º–µ—Å—Ç–æ!)' : ''}</h3>
                            <p><strong>–ü—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å:</strong> ${elem.capacity_per_second} —á–µ–ª/—Å–µ–∫</p>
                            <p><strong>–í—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è:</strong> ${elem.time_through} —Å–µ–∫</p>
                            <p><strong>–ü–ª–æ—Ç–Ω–æ—Å—Ç—å:</strong> ${(elem.density * 100).toFixed(1)}%</p>
                        </div>
                    `;
                });

                content.innerHTML = html;
            }
            
            panel.classList.add('visible');
        }
    </script>
</body>
</html>

